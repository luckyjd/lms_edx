// Generated by CoffeeScript 1.6.1
(function() {

  describe('Problem', function() {
    var problem_content_default;
    problem_content_default = readFixtures('problem_content.html');
    beforeEach(function() {
      window.MathJax = {
        Hub: jasmine.createSpyObj('MathJax.Hub', ['getAllJax', 'Queue']),
        Callback: jasmine.createSpyObj('MathJax.Callback', ['After'])
      };
      this.stubbedJax = {
        root: jasmine.createSpyObj('jax.root', ['toMathML'])
      };
      MathJax.Hub.getAllJax.and.returnValue([this.stubbedJax]);
      window.update_schematics = function() {};
      spyOn(SR, 'readText');
      spyOn(SR, 'readTexts');
      jasmine.stubRequests();
      loadFixtures('problem.html');
      spyOn(Logger, 'log');
      return spyOn($.fn, 'load').and.callFake(function(url, callback) {
        $(this).html(readFixtures('problem_content.html'));
        return callback();
      });
    });
    describe('constructor', function() {
      it('set the element from html', function() {
        this.problem999 = new Problem("        <section class='xblock xblock-student_view xmodule_display xmodule_CapaModule' data-type='Problem'>          <section id='problem_999'                   class='problems-wrapper'                   data-problem-id='i4x://edX/999/problem/Quiz'                   data-url='/problem/quiz/'>          </section>        </section>        ");
        return expect(this.problem999.element_id).toBe('problem_999');
      });
      return it('set the element from loadFixtures', function() {
        this.problem1 = new Problem($('.xblock-student_view'));
        return expect(this.problem1.element_id).toBe('problem_1');
      });
    });
    describe('bind', function() {
      beforeEach(function() {
        spyOn(window, 'update_schematics');
        MathJax.Hub.getAllJax.and.returnValue([this.stubbedJax]);
        return this.problem = new Problem($('.xblock-student_view'));
      });
      it('set mathjax typeset', function() {
        return expect(MathJax.Hub.Queue).toHaveBeenCalled();
      });
      it('update schematics', function() {
        return expect(window.update_schematics).toHaveBeenCalled();
      });
      it('bind answer refresh on button click', function() {
        return expect($('div.action button')).toHandleWith('click', this.problem.refreshAnswers);
      });
      it('bind the submit button', function() {
        return expect($('.action .submit')).toHandleWith('click', this.problem.submit_fd);
      });
      it('bind the reset button', function() {
        return expect($('div.action button.reset')).toHandleWith('click', this.problem.reset);
      });
      it('bind the show button', function() {
        return expect($('.action .show')).toHandleWith('click', this.problem.show);
      });
      it('bind the save button', function() {
        return expect($('div.action button.save')).toHandleWith('click', this.problem.save);
      });
      return it('bind the math input', function() {
        return expect($('input.math')).toHandleWith('keyup', this.problem.refreshMath);
      });
    });
    describe('bind_with_custom_input_id', function() {
      beforeEach(function() {
        spyOn(window, 'update_schematics');
        MathJax.Hub.getAllJax.and.returnValue([this.stubbedJax]);
        this.problem = new Problem($('.xblock-student_view'));
        return $(this).html(readFixtures('problem_content_1240.html'));
      });
      it('bind the submit button', function() {
        return expect($('.action .submit')).toHandleWith('click', this.problem.submit_fd);
      });
      return it('bind the show button', function() {
        return expect($('div.action button.show')).toHandleWith('click', this.problem.show);
      });
    });
    describe('renderProgressState', function() {
      var testProgessData;
      beforeEach(function() {
        return this.problem = new Problem($('.xblock-student_view'));
      });
      testProgessData = function(problem, score, total_possible, attempts, graded, expected_progress_after_render) {
        problem.el.data('problem-score', score);
        problem.el.data('problem-total-possible', total_possible);
        problem.el.data('attempts-used', attempts);
        problem.el.data('graded', graded);
        expect(problem.$('.problem-progress').html()).toEqual("");
        problem.renderProgressState();
        return expect(problem.$('.problem-progress').html()).toEqual(expected_progress_after_render);
      };
      describe('with a status of "none"', function() {
        it('reports the number of points possible and graded', function() {
          return testProgessData(this.problem, 0, 1, 0, "True", "1 point possible (graded)");
        });
        it('displays the number of points possible when rendering happens with the content', function() {
          return testProgessData(this.problem, 0, 2, 0, "True", "2 points possible (graded)");
        });
        it('reports the number of points possible and ungraded', function() {
          return testProgessData(this.problem, 0, 1, 0, "False", "1 point possible (ungraded)");
        });
        it('displays ungraded if number of points possible is 0', function() {
          return testProgessData(this.problem, 0, 0, 0, "False", "0 points possible (ungraded)");
        });
        it('displays ungraded if number of points possible is 0, even if graded value is True', function() {
          return testProgessData(this.problem, 0, 0, 0, "True", "0 points possible (ungraded)");
        });
        it('reports the correct score with status none and >0 attempts', function() {
          return testProgessData(this.problem, 0, 1, 1, "True", "0/1 point (graded)");
        });
        return it('reports the correct score with >1 weight, status none, and >0 attempts', function() {
          return testProgessData(this.problem, 0, 2, 2, "True", "0/2 points (graded)");
        });
      });
      describe('with any other valid status', function() {
        it('reports the current score', function() {
          return testProgessData(this.problem, 1, 1, 1, "True", "1/1 point (graded)");
        });
        it('shows current score when rendering happens with the content', function() {
          return testProgessData(this.problem, 2, 2, 1, "True", "2/2 points (graded)");
        });
        return it('reports the current score even if problem is ungraded', function() {
          return testProgessData(this.problem, 1, 1, 1, "False", "1/1 point (ungraded)");
        });
      });
      return describe('with valid status and string containing an integer like "0" for detail', function() {
        return it('shows 0 points possible for the detail', function() {
          return testProgessData(this.problem, 0, 0, 1, "False", "0 points possible (ungraded)");
        });
      });
    });
    describe('render', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        this.bind = this.problem.bind;
        return spyOn(this.problem, 'bind');
      });
      describe('with content given', function() {
        beforeEach(function() {
          return this.problem.render('Hello World');
        });
        it('render the content', function() {
          return expect(this.problem.el.html()).toEqual('Hello World');
        });
        return it('re-bind the content', function() {
          return expect(this.problem.bind).toHaveBeenCalled();
        });
      });
      return describe('with no content given', function() {
        beforeEach(function() {
          spyOn($, 'postWithPrefix').and.callFake(function(url, callback) {
            return callback({
              html: "Hello World"
            });
          });
          return this.problem.render();
        });
        it('load the content via ajax', function() {
          return expect(this.problem.el.html()).toEqual('Hello World');
        });
        return it('re-bind the content', function() {
          return expect(this.problem.bind).toHaveBeenCalled();
        });
      });
    });
    describe('submit_fd', function() {
      beforeEach(function() {
        $('.xblock-student_view').after('<input type="file" />');
        this.problem = new Problem($('.xblock-student_view'));
        return spyOn(this.problem, 'submit');
      });
      return it('submit method is called if input of type file is not in problem', function() {
        this.problem.submit_fd();
        return expect(this.problem.submit).toHaveBeenCalled();
      });
    });
    describe('submit', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        return this.problem.answers = 'foo=1&bar=2';
      });
      it('log the problem_check event', function() {
        spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
          var promise;
          return promise = {
            always: function(callable) {
              return callable();
            },
            done: function(callable) {
              return callable();
            }
          };
        });
        this.problem.submit();
        return expect(Logger.log).toHaveBeenCalledWith('problem_check', 'foo=1&bar=2');
      });
      it('log the problem_graded event, after the problem is done grading.', function() {
        spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
          var promise, response;
          response = {
            success: 'correct',
            contents: 'mock grader response'
          };
          callback(response);
          return promise = {
            always: function(callable) {
              return callable();
            },
            done: function(callable) {
              return callable();
            }
          };
        });
        this.problem.submit();
        return expect(Logger.log).toHaveBeenCalledWith('problem_graded', ['foo=1&bar=2', 'mock grader response'], this.problem.id);
      });
      it('submit the answer for submit', function() {
        spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
          var promise;
          return promise = {
            always: function(callable) {
              return callable();
            },
            done: function(callable) {
              return callable();
            }
          };
        });
        this.problem.submit();
        return expect($.postWithPrefix).toHaveBeenCalledWith('/problem/Problem1/problem_check', 'foo=1&bar=2', jasmine.any(Function));
      });
      describe('when the response is correct', function() {
        return it('call render with returned content', function() {
          var contents;
          contents = '<div class="wrapper-problem-response" aria-label="Question 1"><p>Correct<span class="status">excellent</span></p></div>' + '<div class="wrapper-problem-response" aria-label="Question 2"><p>Yep<span class="status">correct</span></p></div>';
          spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
            var promise;
            callback({
              success: 'correct',
              contents: contents
            });
            return promise = {
              always: function(callable) {
                return callable();
              },
              done: function(callable) {
                return callable();
              }
            };
          });
          this.problem.submit();
          expect(this.problem.el).toHaveHtml(contents);
          return expect(window.SR.readTexts).toHaveBeenCalledWith(['Question 1: excellent', 'Question 2: correct']);
        });
      });
      describe('when the response is incorrect', function() {
        return it('call render with returned content', function() {
          var contents;
          contents = '<p>Incorrect<span class="status">no, try again</span></p>';
          spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
            var promise;
            callback({
              success: 'incorrect',
              contents: contents
            });
            return promise = {
              always: function(callable) {
                return callable();
              },
              done: function(callable) {
                return callable();
              }
            };
          });
          this.problem.submit();
          expect(this.problem.el).toHaveHtml(contents);
          return expect(window.SR.readTexts).toHaveBeenCalledWith(['no, try again']);
        });
      });
      it('tests if all the capa buttons are disabled while submitting', function(done) {
        var deferred, runs, self;
        deferred = $.Deferred();
        self = this;
        runs = function() {
          spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
            var promise;
            promise = void 0;
            callback({
              success: 'incorrect',
              contents: 'Incorrect'
            });
            return promise = {
              always: function(callable) {
                return callable();
              },
              done: function(callable) {
                return callable();
              }
            };
          });
          spyOn(this.problem, 'enableAllButtons');
          this.problem.submit();
          expect(this.problem.enableAllButtons).toHaveBeenCalledWith(false, true);
          if (jQuery.active === 0) {
            deferred.resolve();
          }
          return deferred.promise();
        };
        return runs.call(self).then(function() {
          expect(self.problem.enableAllButtons).toHaveBeenCalledWith(true, true);
        }).always(done);
      });
      return it('tests the expected change in text of submit button', function(done) {
        var deferred, runs, self;
        deferred = $.Deferred();
        self = this;
        runs = function() {
          spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
            var promise;
            promise = void 0;
            return promise = {
              always: function(callable) {
                return callable();
              },
              done: function(callable) {
                return callable();
              }
            };
          });
          spyOn(this.problem.submitButtonLabel, 'text');
          this.problem.submit();
          expect(this.problem.submitButtonLabel.text).toHaveBeenCalledWith('Submitting');
          if (jQuery.active === 0) {
            deferred.resolve();
          }
          return deferred.promise();
        };
        return runs.call(self).then(function() {
          expect(self.problem.submitButtonLabel.text).toHaveBeenCalledWith('Submit');
        }).always(done);
      });
    });
    describe('submit button on problems', function() {
      beforeEach(function() {
        var _this = this;
        this.problem = new Problem($('.xblock-student_view'));
        return this.submitDisabled = function(disabled) {
          if (disabled) {
            return expect(_this.problem.submitButton).toHaveAttr('disabled');
          } else {
            return expect(_this.problem.submitButton).not.toHaveAttr('disabled');
          }
        };
      });
      describe('some basic tests for submit button', function() {
        return it('should become enabled after a value is entered into the text box', function() {
          $('#input_example_1').val('test').trigger('input');
          this.submitDisabled(false);
          $('#input_example_1').val('').trigger('input');
          return this.submitDisabled(true);
        });
      });
      return describe('some advanced tests for submit button', function() {
        it('should become enabled after a checkbox is checked', function() {
          var html;
          html = '<div class="choicegroup">\n<label for="input_1_1_1"><input type="checkbox" name="input_1_1" id="input_1_1_1" value="1"> One</label>\n<label for="input_1_1_2"><input type="checkbox" name="input_1_1" id="input_1_1_2" value="2"> Two</label>\n<label for="input_1_1_3"><input type="checkbox" name="input_1_1" id="input_1_1_3" value="3"> Three</label>\n</div>';
          $('#input_example_1').replaceWith(html);
          this.problem.submitAnswersAndSubmitButton(true);
          this.submitDisabled(true);
          $('#input_1_1_1').click();
          this.submitDisabled(false);
          $('#input_1_1_1').click();
          return this.submitDisabled(true);
        });
        it('should become enabled after a radiobutton is checked', function() {
          var html;
          html = '<div class="choicegroup">\n<label for="input_1_1_1"><input type="radio" name="input_1_1" id="input_1_1_1" value="1"> One</label>\n<label for="input_1_1_2"><input type="radio" name="input_1_1" id="input_1_1_2" value="2"> Two</label>\n<label for="input_1_1_3"><input type="radio" name="input_1_1" id="input_1_1_3" value="3"> Three</label>\n</div>';
          $('#input_example_1').replaceWith(html);
          this.problem.submitAnswersAndSubmitButton(true);
          this.submitDisabled(true);
          $('#input_1_1_1').attr('checked', true).trigger('click');
          this.submitDisabled(false);
          $('#input_1_1_1').attr('checked', false).trigger('click');
          return this.submitDisabled(true);
        });
        it('should become enabled after a value is selected in a selector', function() {
          var html;
          html = '<div id="problem_sel">\n<select>\n<option value="val0">Select an option</option>\n<option value="val1">1</option>\n<option value="val2">2</option>\n</select>\n</div>';
          $('#input_example_1').replaceWith(html);
          this.problem.submitAnswersAndSubmitButton(true);
          this.submitDisabled(true);
          $("#problem_sel select").val("val2").trigger('change');
          this.submitDisabled(false);
          $("#problem_sel select").val("val0").trigger('change');
          return this.submitDisabled(true);
        });
        it('should become enabled after a radiobutton is checked and a value is entered into the text box', function() {
          var html;
          html = '<div class="choicegroup">\n<label for="input_1_1_1"><input type="radio" name="input_1_1" id="input_1_1_1" value="1"> One</label>\n<label for="input_1_1_2"><input type="radio" name="input_1_1" id="input_1_1_2" value="2"> Two</label>\n<label for="input_1_1_3"><input type="radio" name="input_1_1" id="input_1_1_3" value="3"> Three</label>\n</div>';
          $(html).insertAfter('#input_example_1');
          this.problem.submitAnswersAndSubmitButton(true);
          this.submitDisabled(true);
          $('#input_1_1_1').attr('checked', true).trigger('click');
          this.submitDisabled(true);
          $('#input_example_1').val('111').trigger('input');
          this.submitDisabled(false);
          $('#input_1_1_1').attr('checked', false).trigger('click');
          return this.submitDisabled(true);
        });
        return it('should become enabled if there are only hidden input fields', function() {
          var html;
          html = '<input type="text" name="test" id="test" aria-describedby="answer_test" value="" style="display:none;">';
          $('#input_example_1').replaceWith(html);
          this.problem.submitAnswersAndSubmitButton(true);
          return this.submitDisabled(false);
        });
      });
    });
    describe('reset', function() {
      beforeEach(function() {
        return this.problem = new Problem($('.xblock-student_view'));
      });
      it('log the problem_reset event', function() {
        spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
          var promise;
          return promise = {
            always: function(callable) {
              return callable();
            }
          };
        });
        this.problem.answers = 'foo=1&bar=2';
        this.problem.reset();
        return expect(Logger.log).toHaveBeenCalledWith('problem_reset', 'foo=1&bar=2');
      });
      it('POST to the problem reset page', function() {
        spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
          var promise;
          return promise = {
            always: function(callable) {
              return callable();
            }
          };
        });
        this.problem.reset();
        return expect($.postWithPrefix).toHaveBeenCalledWith('/problem/Problem1/problem_reset', {
          id: 'i4x://edX/101/problem/Problem1'
        }, jasmine.any(Function));
      });
      it('render the returned content', function() {
        spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
          var promise;
          callback({
            html: "Reset",
            success: true
          });
          return promise = {
            always: function(callable) {
              return callable();
            }
          };
        });
        this.problem.reset();
        return expect(this.problem.el.html()).toEqual('Reset');
      });
      it('sends a message to the window SR element', function() {
        spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
          var promise;
          callback({
            html: "Reset",
            success: true
          });
          return promise = {
            always: function(callable) {
              return callable();
            }
          };
        });
        this.problem.reset();
        return expect(window.SR.readText).toHaveBeenCalledWith('This problem has been reset.');
      });
      it('shows a notification on error', function() {
        spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
          var promise;
          callback({
            msg: "Error on reset.",
            success: false
          });
          return promise = {
            always: function(callable) {
              return callable();
            }
          };
        });
        this.problem.reset();
        return expect($('.notification-gentle-alert .notification-message').text()).toEqual("Error on reset.");
      });
      return it('tests if all the buttons are disabled and the text of submit button remains same while resetting', function(done) {
        var deferred, runs, self;
        deferred = $.Deferred();
        self = this;
        runs = function() {
          spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
            var promise;
            promise = void 0;
            return promise = {
              always: function(callable) {
                return callable();
              }
            };
          });
          spyOn(this.problem, 'enableAllButtons');
          this.problem.reset();
          expect(this.problem.enableAllButtons).toHaveBeenCalledWith(false, false);
          expect(this.problem.submitButtonLabel).toHaveText('Submit');
          if (jQuery.active === 0) {
            deferred.resolve();
          }
          return deferred.promise();
        };
        return runs.call(self).then(function() {
          expect(self.problem.enableAllButtons).toHaveBeenCalledWith(true, false);
          return expect(self.problem.submitButtonLabel).toHaveText('Submit');
        }).always(done);
      });
    });
    describe('show', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        return this.problem.el.prepend('<div id="answer_1_1" /><div id="answer_1_2" />');
      });
      return describe('when the answer has not yet shown', function() {
        beforeEach(function() {
          return expect(this.problem.el.find('.show').attr('disabled')).not.toEqual('disabled');
        });
        it('log the problem_show event', function() {
          this.problem.show();
          return expect(Logger.log).toHaveBeenCalledWith('problem_show', {
            problem: 'i4x://edX/101/problem/Problem1'
          });
        });
        it('fetch the answers', function() {
          spyOn($, 'postWithPrefix');
          this.problem.show();
          return expect($.postWithPrefix).toHaveBeenCalledWith('/problem/Problem1/problem_show', jasmine.any(Function));
        });
        it('show the answers', function() {
          spyOn($, 'postWithPrefix').and.callFake(function(url, callback) {
            return callback({
              answers: {
                '1_1': 'One',
                '1_2': 'Two'
              }
            });
          });
          this.problem.show();
          expect($('#answer_1_1')).toHaveHtml('One');
          return expect($('#answer_1_2')).toHaveHtml('Two');
        });
        it('sends a message to the window SR element', function() {
          spyOn($, 'postWithPrefix').and.callFake(function(url, callback) {
            return callback({
              answers: {}
            });
          });
          this.problem.show();
          return expect(window.SR.readText).toHaveBeenCalledWith('Answers to this problem are now shown. Navigate through the problem to review it with answers inline.');
        });
        it('disables the show answer button', function() {
          spyOn($, 'postWithPrefix').and.callFake(function(url, callback) {
            return callback({
              answers: {}
            });
          });
          this.problem.show();
          return expect(this.problem.el.find('.show').attr('disabled')).toEqual('disabled');
        });
        it('sends a SR message when answer is present', function(done) {
          var deferred, runs;
          deferred = $.Deferred();
          runs = function() {
            spyOn($, 'postWithPrefix').and.callFake(function(url, callback) {
              return callback({
                answers: {
                  '1_1': 'answers'
                }
              });
            });
            this.problem.show();
            if (jQuery.active === 0) {
              deferred.resolve();
            }
            return deferred.promise();
          };
          return runs.call(this).then(function() {
            expect(window.SR.readText).toHaveBeenCalledWith('Answers to this problem are now shown. Navigate through the problem to review it with answers inline.');
          }).always(done);
        });
        describe('multiple choice question', function() {
          beforeEach(function() {
            return this.problem.el.prepend('<label for="input_1_1_1"><input type="checkbox" name="input_1_1" id="input_1_1_1" value="1"> One</label>\n<label for="input_1_1_2"><input type="checkbox" name="input_1_1" id="input_1_1_2" value="2"> Two</label>\n<label for="input_1_1_3"><input type="checkbox" name="input_1_1" id="input_1_1_3" value="3"> Three</label>\n<label for="input_1_2_1"><input type="radio" name="input_1_2" id="input_1_2_1" value="1"> Other</label>');
          });
          return it('set the correct_answer attribute on the choice', function() {
            spyOn($, 'postWithPrefix').and.callFake(function(url, callback) {
              return callback({
                answers: {
                  '1_1': [2, 3]
                }
              });
            });
            this.problem.show();
            expect($('label[for="input_1_1_1"]')).not.toHaveAttr('correct_answer', 'true');
            expect($('label[for="input_1_1_2"]')).toHaveAttr('correct_answer', 'true');
            expect($('label[for="input_1_1_3"]')).toHaveAttr('correct_answer', 'true');
            return expect($('label[for="input_1_2_1"]')).not.toHaveAttr('correct_answer', 'true');
          });
        });
        describe('radio text question', function() {
          var radio_text_xml;
          radio_text_xml = '<section class="problem">\n  <div><p></p><span><section id="choicetextinput_1_2_1" class="choicetextinput">\n\n<form class="choicetextgroup capa_inputtype" id="inputtype_1_2_1">\n  <div class="indicator-container">\n    <span class="unanswered" style="display:inline-block;" id="status_1_2_1"></span>\n  </div>\n  <fieldset>\n    <section id="forinput1_2_1_choiceinput_0bc">\n      <input class="ctinput" type="radio" name="choiceinput_1_2_1" id="1_2_1_choiceinput_0bc" value="choiceinput_0"">\n      <input class="ctinput" type="text" name="choiceinput_0_textinput_0" id="1_2_1_choiceinput_0_textinput_0" value=" ">\n      <p id="answer_1_2_1_choiceinput_0bc" class="answer"></p>\n    </>\n    <section id="forinput1_2_1_choiceinput_1bc">\n      <input class="ctinput" type="radio" name="choiceinput_1_2_1" id="1_2_1_choiceinput_1bc" value="choiceinput_1" >\n      <input class="ctinput" type="text" name="choiceinput_1_textinput_0" id="1_2_1_choiceinput_1_textinput_0" value=" " >\n      <p id="answer_1_2_1_choiceinput_1bc" class="answer"></p>\n    </section>\n    <section id="forinput1_2_1_choiceinput_2bc">\n      <input class="ctinput" type="radio" name="choiceinput_1_2_1" id="1_2_1_choiceinput_2bc" value="choiceinput_2" >\n      <input class="ctinput" type="text" name="choiceinput_2_textinput_0" id="1_2_1_choiceinput_2_textinput_0" value=" " >\n      <p id="answer_1_2_1_choiceinput_2bc" class="answer"></p>\n    </section></fieldset><input class="choicetextvalue" type="hidden" name="input_1_2_1" id="input_1_2_1"></form>\n</section></span></div>\n</section>';
          beforeEach(function() {
            return this.problem.el.prepend(radio_text_xml);
          });
          it('sets the correct class on the section for the correct choice', function() {
            spyOn($, 'postWithPrefix').and.callFake(function(url, callback) {
              return callback({
                answers: {
                  "1_2_1": ["1_2_1_choiceinput_0bc"],
                  "1_2_1_choiceinput_0bc": "3"
                }
              });
            });
            this.problem.show();
            expect($('#forinput1_2_1_choiceinput_0bc').attr('class')).toEqual('choicetextgroup_show_correct');
            expect($('#answer_1_2_1_choiceinput_0bc').text()).toEqual('3');
            expect($('#answer_1_2_1_choiceinput_1bc').text()).toEqual('');
            return expect($('#answer_1_2_1_choiceinput_2bc').text()).toEqual('');
          });
          return it('Should not disable input fields', function() {
            spyOn($, 'postWithPrefix').and.callFake(function(url, callback) {
              return callback({
                answers: {
                  "1_2_1": ["1_2_1_choiceinput_0bc"],
                  "1_2_1_choiceinput_0bc": "3"
                }
              });
            });
            this.problem.show();
            expect($('input#1_2_1_choiceinput_0bc').attr('disabled')).not.toEqual('disabled');
            expect($('input#1_2_1_choiceinput_1bc').attr('disabled')).not.toEqual('disabled');
            expect($('input#1_2_1_choiceinput_2bc').attr('disabled')).not.toEqual('disabled');
            return expect($('input#1_2_1').attr('disabled')).not.toEqual('disabled');
          });
        });
        return describe('imageinput', function() {
          var DEFAULTS, assertAnswer, getImage, imageinput_html, stubRequest,
            _this = this;
          imageinput_html = readFixtures('imageinput.underscore');
          DEFAULTS = {
            id: '12345',
            width: '300',
            height: '400'
          };
          beforeEach(function() {
            this.problem = new Problem($('.xblock-student_view'));
            return this.problem.el.prepend(_.template(imageinput_html)(DEFAULTS));
          });
          assertAnswer = function(problem, data) {
            stubRequest(data);
            problem.show();
            return $.each(data['answers'], function(id, answer) {
              var el, img;
              img = getImage(answer);
              el = $('#inputtype_' + id);
              return expect(img).toImageDiffEqual(el.find('canvas')[0]);
            });
          };
          stubRequest = function(data) {
            return spyOn($, 'postWithPrefix').and.callFake(function(url, callback) {
              return callback(data);
            });
          };
          getImage = function(coords, c_width, c_height) {
            var canvas, ctx, types;
            types = {
              rectangle: function(coords) {
                var rects, reg;
                reg = /^\(([0-9]+),([0-9]+)\)-\(([0-9]+),([0-9]+)\)$/;
                rects = coords.replace(/\s*/g, '').split(/;/);
                $.each(rects, function(index, rect) {
                  var abs, height, points, width;
                  abs = Math.abs;
                  points = reg.exec(rect);
                  if (points) {
                    width = abs(points[3] - points[1]);
                    height = abs(points[4] - points[2]);
                    return ctx.rect(points[1], points[2], width, height);
                  }
                });
                ctx.stroke();
                return ctx.fill();
              },
              regions: function(coords) {
                var parseCoords;
                parseCoords = function(coords) {
                  var reg;
                  reg = JSON.parse(coords);
                  if (typeof reg[0][0][0] === "undefined") {
                    reg = [reg];
                  }
                  return reg;
                };
                return $.each(parseCoords(coords), function(index, region) {
                  ctx.beginPath();
                  $.each(region, function(index, point) {
                    if (index === 0) {
                      return ctx.moveTo(point[0], point[1]);
                    } else {
                      return ctx.lineTo(point[0], point[1]);
                    }
                  });
                  ctx.closePath();
                  ctx.stroke();
                  return ctx.fill();
                });
              }
            };
            canvas = document.createElement('canvas');
            canvas.width = c_width || 100;
            canvas.height = c_height || 100;
            if (canvas.getContext) {
              ctx = canvas.getContext('2d');
            } else {
              return console.log('Canvas is not supported.');
            }
            ctx.fillStyle = 'rgba(255,255,255,.3)';
            ctx.strokeStyle = "#FF0000";
            ctx.lineWidth = "2";
            $.each(coords, function(key, value) {
              if ((types[key] != null) && value) {
                return types[key](value);
              }
            });
            return canvas;
          };
          it('rectangle is drawn correctly', function() {
            return assertAnswer(this.problem, {
              'answers': {
                '12345': {
                  'rectangle': '(10,10)-(30,30)',
                  'regions': null
                }
              }
            });
          });
          it('region is drawn correctly', function() {
            return assertAnswer(this.problem, {
              'answers': {
                '12345': {
                  'rectangle': null,
                  'regions': '[[10,10],[30,30],[70,30],[20,30]]'
                }
              }
            });
          });
          it('mixed shapes are drawn correctly', function() {
            return assertAnswer(this.problem, {
              'answers': {
                '12345': {
                  'rectangle': '(10,10)-(30,30);(5,5)-(20,20)',
                  'regions': '[\n  [[50,50],[40,40],[70,30],[50,70]],\n  [[90,95],[95,95],[90,70],[70,70]]\n]'
                }
              }
            });
          });
          it('multiple image inputs draw answers on separate canvases', function() {
            var data;
            data = {
              id: '67890',
              width: '400',
              height: '300'
            };
            this.problem.el.prepend(_.template(imageinput_html)(data));
            return assertAnswer(this.problem, {
              'answers': {
                '12345': {
                  'rectangle': null,
                  'regions': '[[10,10],[30,30],[70,30],[20,30]]'
                },
                '67890': {
                  'rectangle': '(10,10)-(30,30)',
                  'regions': null
                }
              }
            });
          });
          return it('dictionary with answers doesn\'t contain answer for current id', function() {
            var el;
            spyOn(console, 'log');
            stubRequest({
              'answers': {}
            });
            this.problem.show();
            el = $('#inputtype_12345');
            expect(el.find('canvas')).not.toExist();
            return expect(console.log).toHaveBeenCalledWith('Answer is absent for image input with id=12345');
          });
        });
      });
    });
    describe('save', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        return this.problem.answers = 'foo=1&bar=2';
      });
      it('log the problem_save event', function() {
        spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
          var promise;
          return promise = {
            always: function(callable) {
              return callable();
            }
          };
        });
        this.problem.save();
        return expect(Logger.log).toHaveBeenCalledWith('problem_save', 'foo=1&bar=2');
      });
      it('POST to save problem', function() {
        spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
          var promise;
          return promise = {
            always: function(callable) {
              return callable();
            }
          };
        });
        this.problem.save();
        return expect($.postWithPrefix).toHaveBeenCalledWith('/problem/Problem1/problem_save', 'foo=1&bar=2', jasmine.any(Function));
      });
      return it('tests if all the buttons are disabled and the text of submit button does not change while saving.', function(done) {
        var curr_html, deferred, runs, self;
        deferred = $.Deferred();
        self = this;
        curr_html = this.problem.el.html();
        runs = function() {
          spyOn($, 'postWithPrefix').and.callFake(function(url, answers, callback) {
            var promise;
            promise = void 0;
            callback({
              success: 'correct',
              html: curr_html
            });
            return promise = {
              always: function(callable) {
                return callable();
              }
            };
          });
          spyOn(this.problem, 'enableAllButtons');
          this.problem.save();
          expect(this.problem.enableAllButtons).toHaveBeenCalledWith(false, false);
          expect(this.problem.submitButtonLabel).toHaveText('Submit');
          if (jQuery.active === 0) {
            deferred.resolve();
          }
          return deferred.promise();
        };
        return runs.call(self).then(function() {
          expect(self.problem.enableAllButtons).toHaveBeenCalledWith(true, false);
          return expect(self.problem.submitButtonLabel).toHaveText('Submit');
        }).always(done);
      });
    });
    describe('refreshMath', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        $('#input_example_1').val('E=mc^2');
        return this.problem.refreshMath({
          target: $('#input_example_1').get(0)
        });
      });
      return it('should queue the conversion and MathML element update', function() {
        return expect(MathJax.Hub.Queue).toHaveBeenCalledWith(['Text', this.stubbedJax, 'E=mc^2'], [this.problem.updateMathML, this.stubbedJax, $('#input_example_1').get(0)]);
      });
    });
    describe('updateMathML', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        return this.stubbedJax.root.toMathML.and.returnValue('<MathML>');
      });
      describe('when there is no exception', function() {
        beforeEach(function() {
          return this.problem.updateMathML(this.stubbedJax, $('#input_example_1').get(0));
        });
        return it('convert jax to MathML', function() {
          return expect($('#input_example_1_dynamath')).toHaveValue('<MathML>');
        });
      });
      return describe('when there is an exception', function() {
        beforeEach(function() {
          var error;
          error = new Error();
          error.restart = true;
          this.stubbedJax.root.toMathML.and.throwError(error);
          return this.problem.updateMathML(this.stubbedJax, $('#input_example_1').get(0));
        });
        return it('should queue up the exception', function() {
          return expect(MathJax.Callback.After).toHaveBeenCalledWith([this.problem.refreshMath, this.stubbedJax], true);
        });
      });
    });
    describe('refreshAnswers', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        this.problem.el.html('<textarea class="CodeMirror" />\n<input id="input_1_1" name="input_1_1" class="schematic" value="one" />\n<input id="input_1_2" name="input_1_2" value="two" />\n<input id="input_bogus_3" name="input_bogus_3" value="three" />');
        this.stubSchematic = {
          update_value: jasmine.createSpy('schematic')
        };
        this.stubCodeMirror = {
          save: jasmine.createSpy('CodeMirror')
        };
        $('input.schematic').get(0).schematic = this.stubSchematic;
        return $('textarea.CodeMirror').get(0).CodeMirror = this.stubCodeMirror;
      });
      it('update each schematic', function() {
        this.problem.refreshAnswers();
        return expect(this.stubSchematic.update_value).toHaveBeenCalled();
      });
      return it('update each code block', function() {
        this.problem.refreshAnswers();
        return expect(this.stubCodeMirror.save).toHaveBeenCalled();
      });
    });
    describe('multiple JsInput in single problem', function() {
      var jsinput_html;
      jsinput_html = readFixtures('jsinput_problem.html');
      beforeEach(function() {
        this.problem = new Problem($('.xblock-student_view'));
        return this.problem.render(jsinput_html);
      });
      return it('submit_save_waitfor should return false', function() {
        $(this.problem.inputs[0]).data('waitfor', function() {});
        return expect(this.problem.submit_save_waitfor()).toEqual(false);
      });
    });
    describe('Submitting an xqueue-graded problem', function() {
      var matlabinput_html;
      matlabinput_html = readFixtures('matlabinput_problem.html');
      beforeEach(function() {
        spyOn($, 'postWithPrefix').and.callFake(function(url, callback) {
          return callback({
            html: matlabinput_html
          });
        });
        jasmine.clock().install();
        this.problem = new Problem($('.xblock-student_view'));
        spyOn(this.problem, 'poll').and.callThrough();
        return this.problem.render(matlabinput_html);
      });
      afterEach(function() {
        return jasmine.clock().uninstall();
      });
      return it('check that we stop polling after a fixed amount of time', function() {
        var num_calls, time_step, time_steps, _fn, _i, _len,
          _this = this;
        expect(this.problem.poll).not.toHaveBeenCalled();
        jasmine.clock().tick(1);
        time_steps = [1000, 2000, 4000, 8000, 16000, 32000];
        num_calls = 1;
        _fn = function(time_step) {
          jasmine.clock().tick(time_step);
          expect(_this.problem.poll.calls.count()).toEqual(num_calls);
          return num_calls += 1;
        };
        for (_i = 0, _len = time_steps.length; _i < _len; _i++) {
          time_step = time_steps[_i];
          _fn(time_step);
        }
        jasmine.clock().tick(64000);
        expect(this.problem.poll.calls.count()).toEqual(6);
        return expect($('.notification-gentle-alert .notification-message').text()).toEqual("The grading process is still running. Refresh the page to see updates.");
      });
    });
    return describe('codeinput problem', function() {
      var codeinputProblemHtml;
      codeinputProblemHtml = readFixtures('codeinput_problem.html');
      beforeEach(function() {
        spyOn($, 'postWithPrefix').and.callFake(function(url, callback) {
          return callback({
            html: codeinputProblemHtml
          });
        });
        this.problem = new Problem($('.xblock-student_view'));
        return this.problem.render(codeinputProblemHtml);
      });
      return it('has rendered with correct a11y info', function() {
        var CodeMirrorTextArea, CodeMirrorTextAreaId;
        CodeMirrorTextArea = $('textarea')[1];
        CodeMirrorTextAreaId = 'cm-textarea-101';
        expect($('.problem-group-label').attr('for')).toEqual(CodeMirrorTextAreaId);
        expect($(CodeMirrorTextArea).attr('id')).toEqual(CodeMirrorTextAreaId);
        return expect($(CodeMirrorTextArea).attr('aria-describedby')).toEqual('cm-editor-exit-message-101 status_101');
      });
    });
  });

}).call(this);
